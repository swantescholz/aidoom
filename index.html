<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Map of AI Doom</title>
<style>
    body, html {
        height: 100%;
        margin: 0;
        font-family: Arial, sans-serif;
        font-size: smaller;
    }
    canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none; /* This allows clicking through the canvas */
    }
    table {
        margin: 10px;
        border: 1px solid black;
        border-collapse: collapse;
    }
    td, th {
        border: 1px solid black;
        padding-left: 5px;
        padding-right: 5px;
        height: auto;
    }
    input[type="number"] {
        margin-left: 5px; /* Adds some space around the inputs */
    }
    input[type="number"] {
        width: 40px; /* Fixed width for the number inputs */
    }
    input[type="range"] {
        flex-grow: 1; /* Allows the slider to fill the rest of the container */
    }
    #layoutRow1 {
        display: flex;
        align-items: center; 
    }
    #layoutRow2 {
        display: flex;
        align-items: flex-start; 
    }
    #canvas-container {
        position: relative;
        border: 1px solid black;
        flex-shrink: 0;
        margin: 5px;
    }
    #slider-container-outer {
        padding: 10px;
        border: 1px solid black;
        flex-shrink: 0;
    }
    .node {
        position: absolute;
        border: 1px solid black;
        text-align: center;
        padding: 5px;
        transform: translate(-50%, -50%);
    }
    .edge-label {
        position: absolute;
        text-align: center;
        transform: translate(-50%, -50%);
    }
    .tablePercent {
        text-align: right;
        width: 30px;
    }
    .bgs { background-color: rgb(114, 158, 240);}
    .bgn { background-color: rgb(255, 255, 255); }
    .bgg { background-color: rgb(97, 247, 115); }
    .bga { background-color: rgb(244, 244, 99); }
    .bgc { background-color: rgb(234, 138, 49); }
    .bge { background-color: rgb(223, 94, 55); }
    .slider-container-inner {
        width: 100%;
        display: flex;         /* Aligns children (slider and textbox) in a row */
        align-items: center;     /* Centers the children vertically */
    }
</style>
</head>
<body>
<script>

// start first, then normal nodes, then the rest!
let nodesStr = `
s;agi possible;500;0;START|Is AGI possible?
n;agi century;500;200;Can we build|AGI this century?
n;agi aligned;500;400;Will we|align AGI?
c;ai catastrophe;0;300;pre-AGI|catastrophe
g;agi utopia;800;500;AGI utopia
a;ai winter;1000;100;AI winter
e;agi xrisk;0;500;AGI existential|catastrophe
`.trim();

let edgesStr = `
y;agi possible;agi century
n;agi possible;ai winter
y;agi century;agi aligned
n;agi century;ai catastrophe
y;agi aligned;agi utopia
n;agi aligned;agi xrisk
`.trim();

// Edge types
const YES = 'y';
const NO = 'n';

// Node types:
const NORMAL = 'n';
const START = 's';
const GOOD = 'g';
const AMBIVALENT = 'a';
const CATASTROPHIC = 'c';
const EXISTENTIAL = 'e';

// Other constants
const XSCALE = 0.7;
const YSCALE = 0.8;
const SLIDER_DEFAULT_VALUE = 50;
const TABLE_NODE_TYPES = [EXISTENTIAL, CATASTROPHIC, AMBIVALENT, GOOD, NORMAL];
const TABLE_HEADERS = ["Existential Catastrophe", "Non-existential Catastrophe", "Ambivalent Outcome", "Good Outcome", "Intermediate State (propability<br>of *entering* this state)"];

let gNodeIndex = 0;

class Node {
    constructor(line) {
        const parts = line.trim().split(';');
        this.index = gNodeIndex++;
        this.id = parts[1];
        this.type = parts[0];
        this.x = parseFloat(parts[2]) * XSCALE;
        this.y = parseFloat(parts[3]) * YSCALE;
        this.text = parts[4].replace('|', '\n');
        this.p = 1.0; // total probability flow going into this node.
    }
}
const CANVAS_PADDINGW = 100;
const CANVAS_PADDINGH = 50;
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 800;
function initNodes() {
    let nodes = nodesStr.split('\n').map(line => new Node(line));
    let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
    nodes.map(node => {
        minX = Math.min(minX, node.x);
        minY = Math.min(minY, node.y);
        maxX = Math.max(maxX, node.x);
        maxY = Math.max(maxY, node.y);
    });
    nodes.map(node => {
        node.x = (node.x - minX) / (maxX-minX) * (CANVAS_WIDTH - 2*CANVAS_PADDINGW) + CANVAS_PADDINGW;
        node.y = (node.y - minY) / (maxY-minY) * (CANVAS_HEIGHT - 2*CANVAS_PADDINGH) + CANVAS_PADDINGH;
    })
    return nodes;
}
const nodes = initNodes();
let id2index = new Map();
nodes.map((node, index) => {
    id2index.set(node.id, index);
});

class Edge {
    constructor(line) {
        const parts = line.trim().split(';');
        this.yn = parts[0];
        this.source = id2index.get(parts[1]);
        this.target = id2index.get(parts[2]);
        this.p = 0.0; // total probability flow going through the edge.
    }
}

let edges = edgesStr.split('\n').map(line => new Edge(line));
const Q = nodes.filter(n => n.type === NORMAL || n.type === START).length;
const N = nodes.length;
const E = edges.length;

let adj = new Map();
edges.map((edge, eIndex) => {
    if (!adj.has(edge.target)) {
        adj.set(edge.target, []);
    }
    adj.get(edge.target).push(eIndex);
});
// ================================ HEADER 
// Write lorem ipsum text
document.write(`
    <h1>Map of AI Doom</h1>
    Legend/glossary. Link to e.g. AGI wikipedia entry?

    Say that sliders are conditional on that state being entered in the graph!
    Say that this is a simplified model and were likely wrong about various things.
    Define catastrophic risks, e.g. as covid level (death toll or economic impact) or worse
`);

// ================================ ROW 1

document.write(`<div id="layoutRow1">`);
    
    document.write(`<p>foobar</p>`);
    
document.write(`<div id="canvas-container" style="width: ${CANVAS_WIDTH}px; height: ${CANVAS_HEIGHT}px">`);
    document.write(`<canvas s></canvas>`);
nodes.map(node => {
    document.write(`
<div id="node${node.index}" class="node bg${node.type}" style="top: ${node.y}px; left: ${node.x}px;">
    ${node.text.replace(/\n/g, '<br>')}
</div>`);
});
edges.map((edge, index) => {
    document.write(`<div id="edge-label${index}" class="edge-label">${edge.yn}</div>`);
});
document.write(`</div>`); // /canvas-container
document.write(`<div id=slider-container-outer>`); // slider
    // Settings
    document.write(`
<div class="slider-container-inner"> 
    <p style="padding-left: 5px">Make more likely paths bolder?</p>
    <input type="checkbox" id="boldPathsCheckbox" onclick="updateEverything()" checked>
</div>
<div class="slider-container-inner"> 
    <p style="padding-left: 5px">Make less likely paths transparent?</p>
    <input type="checkbox" id="transparentPathsCheckbox" onclick="updateEverything()" checked>
</div>
<hr>
<button onclick="setSlidersFromString('50i50i50')">Reset all to 50%</button>
<button onclick="setSlidersFromString('81i21i73')">Swante's estimates</button>
<br>
<button onclick="setSlidersFromString('50i50i50')">AAA's estimates</button>
<button onclick="setSlidersFromString('50i50i50')">BBB's estimates</button>
<hr>
`);

for (let i = 0; i < Q; i++) {
    document.write(`
<p style="padding-left: 5px">${nodes[i].text.replace("START", "").trim()}</p>
<div class="slider-container-inner"> 
    <input type="range" id="slider${i}" min="0" max="100" value="${SLIDER_DEFAULT_VALUE}"> 
    <input type="number" id="slidernumberbox${i}" min="0" max="100" value="${SLIDER_DEFAULT_VALUE}"> 
</div>
`);
}
document.write('</div>'); // /slider
document.write(`</div>`); // /layoutRow1
// ================================ ROW 2
document.write(`<div id="layoutRow2">`);
for (let i = 0; i < TABLE_NODE_TYPES.length; i++) {
    document.write(`<table class="bg${TABLE_NODE_TYPES[i]}"><tr><th>${TABLE_HEADERS[i]}</th><th class="ralign">[%]</th></tr>`);
        if (TABLE_NODE_TYPES[i] !== NORMAL) {
            document.write(`<tr><td><b>Total</b></td><td class="tablePercent"><b><p id="pTableTotalForType${TABLE_NODE_TYPES[i]}">0.0</p></b></td></tr>`);
        } 
    nodes.filter(n => n.type === TABLE_NODE_TYPES[i]).map(node => {
        document.write(`<tr><td>${node.text}</td><td class="tablePercent"><p id="pNodeCell${node.index}">0.0</p></td></tr>`);
    });
    document.write(`</table>`);
}
document.write(`</div>`); // /layoutRow2
const canvas = document.querySelector('canvas');
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;
    const ctx = canvas.getContext('2d');
// ================================ FUNCTIONS
const clamp01 = x => Math.min(1.0, Math.max(0.0, x));
const toPercentString = p => (p*100).toFixed(1);
function toAlpha(p) {
    if (document.getElementById('transparentPathsCheckbox').checked) {
        return interpolateFast(p, 0.2, 1.0);
    }
    return 1.0;
}
function toArrowWidth(p) {
    if (document.getElementById('boldPathsCheckbox').checked) {
        return interpolateFast(p, 1, 5);
    }
    return 2;
}
function toArrowHeadLen(p) {
    if (document.getElementById('boldPathsCheckbox').checked) {
        return interpolateFast(p, 8, 25);
    }
    return 12;
}
function toNodeBorderWidth(p) {
    if (document.getElementById('boldPathsCheckbox').checked) {
        return interpolateFast(p, 1, 5);
    }
    return 2;
}
function toNodeFontWeight(p) {
    if (document.getElementById('boldPathsCheckbox').checked) {
        return interpolateFast(p, 100, 900);
    }
    return 400;
}
function interpolateFast(p, min, max) {
    p = clamp01(p);
    p = Math.sqrt(1.0-(1-p)*(1-p)); // fast-in circle function
    return min + (max - min) * p; // linear interpolation between min and max
}
function updateEverything() {
    updateUrl();
    updateProbabilities();
    updateTables();
    updateNodeStyles();
    drawArrows();
}
function updateUrl() {
    let sliderValues = '';
    for (let i = 0; i < Q; i++) {
        sliderValues += document.getElementById('slider' + i).value;
        if (i + 1 < Q) {
            sliderValues += 'i';
        }
    }
    let params = new URLSearchParams(window.location.search);
    params.set('p', sliderValues);
    window.history.replaceState({}, '', `${window.location.pathname}?${params}`);
}
function updateProbabilities() {
    let sliderProbs = [];
    for (let i = 0; i < Q; i++) {
        sliderProbs.push(parseInt(document.getElementById('slider' + i).value)/100.0);
    }
    let np = new Map([[0, 1.0]]);
    let ep = new Map();
    function pNode(nIndex) {
        if (np.has(nIndex)) {
            return np.get(nIndex);
        }
        let p = adj.get(nIndex).map(eIndex => pEdge(eIndex)).reduce((a, b) => a + b, 0.0);
        np[nIndex] = p;
        nodes[nIndex].p = p;
        return p;
    }
    function pEdge(eIndex) {
        if (ep.has(eIndex)) {
            return ep.get(eIndex);
        }
        let edge = edges[eIndex];
        let pParent = pNode(edge.source);
        let pSlider = sliderProbs[edge.source];
        let p = edge.yn === YES ? pSlider : 1.0 - pSlider;
        console.log('pEdge', eIndex, p, pParent);
        p *= pParent;
        ep.set(eIndex, p);
        edges[eIndex].p = p;
        return p;
    }
    for (let i = 0; i < N; i++) {
        pNode(i);
    }    
}
function updateTables() {
    for (let i = 0; i < N; i++) {
        let cell = document.getElementById('pNodeCell' + i);
        if (cell) {
            cell.innerText = toPercentString(nodes[i].p);
        }
    }
    for (let i = 0; i < TABLE_NODE_TYPES.length; i++) {
        if (TABLE_NODE_TYPES[i] === NORMAL) {
            continue;
        }
        let total = nodes.filter(n => n.type === TABLE_NODE_TYPES[i]).map(n => n.p).reduce((a, b) => a + b, 0.0);
        document.getElementById('pTableTotalForType' + TABLE_NODE_TYPES[i]).innerText = toPercentString(total);
    }
}
function updateNodeStyles() {
    for (let i = 0; i < N; i++) {
        let nodeDiv = document.getElementById(`node${i}`);
        nodeDiv.style.opacity = toAlpha(nodes[i].p);
        nodeDiv.style.fontWeight = toNodeFontWeight(nodes[i].p);
        nodeDiv.style.borderWidth = toNodeBorderWidth(nodes[i].p) + 'px';
    }
}
function drawArrows() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const canvasRect = document.getElementById(`canvas-container`).getBoundingClientRect()
    for (let i = 0; i < E; i++) {
        const edge = edges[i];
        const box1 = document.getElementById(`node${edge.source}`);
        const box2 = document.getElementById(`node${edge.target}`);
        const rect1 = box1.getBoundingClientRect();
        const rect2 = box2.getBoundingClientRect();
        let x1 = rect1.left - canvasRect.left + rect1.width / 2;
        let y1 = rect1.top - canvasRect.top + rect1.height / 2;
        let x2 = rect2.left - canvasRect.left + rect2.width / 2;
        let y2 = rect2.top - canvasRect.top + rect2.height / 2;
        let dx = parseFloat(x2) - x1;
        let dy = parseFloat(y2) - y1;
        // Make arrow endpoints align with mid-line or corner points of the boxes.
        if (dx > rect1.width / 2) {
            x1 += rect1.width / 2;
        } else if (dx < -rect1.width / 2) {
            x1 -= rect1.width / 2;
        }
        if (dy > rect1.height / 2) {
            y1 += rect1.height / 2;
        } else if (dy < -rect1.height / 2) {
            y1 -= rect1.height / 2;
        }
        if (dx > rect2.width / 2) {
            x2 -= rect2.width / 2;
        } else if (dx < -rect2.width / 2) {
            x2 += rect2.width / 2;
        }
        if (dy > rect2.height / 2) {
            y2 -= rect2.height / 2;
        } else if (dy < -rect2.height / 2) {
            y2 += rect2.height / 2;
        }
        x1 -= 1; // for some reasons these are needed to make the arrows look perfectly aligned.
        x2 -= 1;
        y1 -= 1;
        y2 -= 1;

        updateEdgeLabel(i, x1, y1, x2, y2);

        dx = parseFloat(x2) - x1; // calculate line offset for arrow head
        dy = parseFloat(y2) - y1;
        let dlen = Math.sqrt(dx*dx + dy*dy);
        dx = dx / dlen * toArrowHeadLen(edge.p) * 0.866;
        dy = dy / dlen * toArrowHeadLen(edge.p) * 0.866;
        
        // Draw the line
        ctx.beginPath();
        ctx.moveTo(x1 - canvas.offsetLeft, y1 - canvas.offsetTop);
        // Retract the line end a bit so that it doesn't overlap the arrow head.
        ctx.lineTo(x2 - canvas.offsetLeft - dx, y2 - canvas.offsetTop - dy);
        ctx.strokeStyle = `rgba(0, 0, 0, ${toAlpha(edge.p)}`;
        ctx.lineWidth = toArrowWidth(edge.p);
        ctx.stroke();

        // Draw the arrow head
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const headlen = toArrowHeadLen(edge.p);  // length of head in pixels
        ctx.beginPath();
        ctx.moveTo(x2 - canvas.offsetLeft, y2 - canvas.offsetTop);
        ctx.lineTo(x2 - canvas.offsetLeft - headlen * Math.cos(angle - Math.PI / 6), y2 - canvas.offsetTop - headlen * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(x2 - canvas.offsetLeft - headlen * Math.cos(angle + Math.PI / 6), y2 - canvas.offsetTop - headlen * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(x2 - canvas.offsetLeft, y2 - canvas.offsetTop);
        ctx.closePath();
        ctx.fillStyle = `rgba(0, 0, 0, ${toAlpha(edge.p)}`;
        ctx.fill();
    }
}
function updateEdgeLabel(i, x1, y1, x2, y2) {
    const edgeLabel = document.getElementById(`edge-label${i}`);
    let dx = y2 - y1;
    let dy = x1 - x2;
    const norm = Math.sqrt(dx*dx + dy*dy);
    const offset = 8 + toArrowWidth(edges[i].p) * 0.5
    dx = dx / norm * offset;
    dy = dy / norm * offset;
    edgeLabel.style.left = dx + (x1 + x2) / 2 + 'px';
    edgeLabel.style.top = dy + (y1 + y2) / 2 + 'px';
    edgeLabel.style.opacity = toAlpha(edges[i].p);
}
function setSlidersFromString(s) {
    let parts = s.split('i');
    for (let i = 0; i < Q; i++) {
        let slider = document.getElementById('slider' + i);
        let textbox = document.getElementById('slidernumberbox' + i);
        slider.value = parseInt(parts[i]) || SLIDER_DEFAULT_VALUE;
        textbox.value = slider.value;
    }
}
window.onload = function () {
    let urlParam = new URLSearchParams(window.location.search).get('p') || '';
    setSlidersFromString(urlParam);
    // Slider listeners.
    for (let i = 0; i < Q; i++) {
        let slider = document.getElementById('slider' + i);
        let textbox = document.getElementById('slidernumberbox' + i);
        slider.addEventListener('input', function () {
            textbox.value = slider.value;
            updateEverything();
        });
        textbox.addEventListener('input', function () {
            if (textbox.value < 0) {
                textbox.value = 0;
            } else if (textbox.value > 100) {
                textbox.value = 100;
            }
            slider.value = textbox.value;
            updateEverything();
        });
    }
    updateEverything();
};
window.onresize = updateEverything;

// ================================ END
</script>
</body>
</html>
