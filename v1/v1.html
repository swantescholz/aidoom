<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map of AI Doom</title>
    <link rel="stylesheet" type="text/css" href="styles.css">
    <script src="constants.js"></script>
</head>

<body>
<script>


let gNodeIndex = 0;

class Node {
    constructor(line) {
        const parts = line.trim().split(';');
        this.index = gNodeIndex++;
        this.id = parts[1];
        this.type = parts[0];
        this.x = parseFloat(parts[2]) * XSCALE;
        this.y = parseFloat(parts[3]);
        this.text = parts[4].replace('|', '\n');
        this.p = 1.0; // total probability flow going into this node.
    }
}

function initNodes() {
    let nodes = nodesStr.split('\n').map(line => new Node(line));
    let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
    nodes.map(node => {
        minX = Math.min(minX, node.x);
        minY = Math.min(minY, node.y);
        maxX = Math.max(maxX, node.x);
        maxY = Math.max(maxY, node.y);
    });
    nodes.map(node => {
        node.x = (node.x - minX) / (maxX-minX) * (CANVAS_WIDTH - 2*CANVAS_PADDINGW) + CANVAS_PADDINGW;
        node.y = (node.y - minY) / (maxY-minY) * (CANVAS_HEIGHT - 2*CANVAS_PADDINGH) + CANVAS_PADDINGH;
    })
    return nodes;
}
const nodes = initNodes();
let id2index = new Map();
nodes.map((node, index) => {
    id2index.set(node.id, index);
});
const normalNodesIndices = nodes.filter(n => n.type === NORMAL).map(n => n.index);

class Edge {
    constructor(line) {
        const parts = line.trim().split(';');
        this.yn = parts[0];
        this.source = id2index.get(parts[1]);
        this.target = id2index.get(parts[2]);
        mycheck(this.source, `Unknown node: ${parts[1]}`);
        mycheck(this.target, `Unknown node: ${parts[2]}`);
        this.p = 0.0; // total probability flow going through the edge.
    }
}

let edges = edgesStr.split('\n').map(line => new Edge(line));
const Q = normalNodesIndices.length;
const N = nodes.length;
const E = edges.length;

let adj = new Map();
edges.map((edge, eIndex) => {
    if (!adj.has(edge.target)) {
        adj.set(edge.target, []);
    }
    adj.get(edge.target).push(eIndex);
});
let probabilityRootNodeIndex = nodes.findIndex(n => n.type === START);
// ================================ HEADER 
document.write(`
<div id="mainContent">
    <h1>Map of AI Doom (<a href="http://bit.ly/map-of-ai-doom">bit.ly/map-of-ai-doom</a>)</h1>
    
    TODO:
    <br>Legend/glossary. 
    <br>Explain sliders use conditional probabilities.
    <br>Define catastrophic risks.
    <br>add authors, and link to source code. mention unlicense, so people know they may modify etc.
`);

// ================================ SHARING / EXPORT
document.write(`
<div id="shareRow">
<h2>Share this page:</h2>
    <button onclick="copyUrlToClipboard()" class="shareButton">Copy URL to Clipboard</button>
    <button onclick="shareOnFacebook()" class="shareButton">Share on Facebook</button>
    <button onclick="shareOnTwitter()" class="shareButton">Share on X (Twitter)</button>
</div>
`);
// ================================ ROW 1

document.write(`<div id="layoutRow1">`);
document.write(`<div id="canvas-container" style="width: ${CANVAS_WIDTH}px; height: ${CANVAS_HEIGHT}px">`);
document.write(`<canvas></canvas>`);
nodes.map(node => {
    document.write(`
    <div id="${idDivNodeBox+node.index}" class="nodeBox bg${node.type}" style="top: ${node.y}px; left: ${node.x}px;" onclick="handleNodeClick(${node.index})"></div>
    <div id="${idDivNodeText+node.index}" class="nodeText" style="top: ${node.y}px; left: ${node.x}px;" onclick="handleNodeClick(${node.index})">${node.text.replace(/\n/g, '<br>')}</div>
    `);
});
edges.map((edge, index) => {
    document.write(`<div id="edge-label${index}" class="edge-label">${edge.yn === E100 ? "" : edge.yn}</div>`);
});
document.write(`</div>`); // /canvas-container
document.write(`<div id=slider-container-outer>`); // slider
    // Settings=================================
    document.write(`
<div class="slider-container-inner"> 
    <p style="padding-left: 5px">Make more likely paths bolder?</p>
    <input type="checkbox" id="boldPathsCheckbox" onclick="updateEverything()" checked>
</div>
<div class="slider-container-inner"> 
    <p style="padding-left: 5px">Make less likely paths transparent?</p>
    <input type="checkbox" id="transparentPathsCheckbox" onclick="updateEverything()" checked>
</div>
<hr>
<button onclick="setSlidersFromString('')">Reset all to 50%</button>
<button onclick="setSlidersFromString('4i80i1i90i55i10i30i10i97i60i70i3i75i70i50i80i90i75i25i5i80i6i92i2')">Author's estimates</button>
<hr>
`);

for (let i = 0; i < Q; i++) {
    document.write(`
<p style="padding-left: 5px">${nodes[normalNodesIndices[i]].text.trim()}</p>
<div class="slider-container-inner"> 
    <input type="range" id="slider${i}" min="0" max="100" value="${SLIDER_DEFAULT_VALUE}"> 
    <input type="number" id="slidernumberbox${i}" min="0" max="100" value="${SLIDER_DEFAULT_VALUE}"> 
</div>
`);
}
document.write('</div>'); // /slider
document.write(`</div>`); // /layoutRow1
// ================================ ROW 2
document.write(`<div id="layoutRow2">`);
for (let i = 0; i < TABLE_NODE_TYPES.length; i++) {
    document.write(`<table class="bg${TABLE_NODE_TYPES[i]}"><tr><th>${TABLE_HEADERS[i]}</th><th class="ralign">[%]</th></tr>`);
        if (TABLE_NODE_TYPES_WITH_TOTAL.includes(TABLE_NODE_TYPES[i])) {
            document.write(`<tr><td><b>Total</b></td><td class="tablePercent"><b><p id="${idPTableTotalForType}${TABLE_NODE_TYPES[i]}">0.0</p></b></td></tr>`);
        } 
    nodes.filter(n => n.type === TABLE_NODE_TYPES[i]).map(node => {
        document.write(`<tr><td>${node.text}</td><td class="tablePercent"><p id="pNodeCell${node.index}">0.0</p></td></tr>`);
    });
    document.write(`</table>`);
}
document.write(`</div>`); // /layoutRow2
document.write(`</div>`); // /mainContent
// ================================ FUNCTIONS / LOGIC
const canvas = document.querySelector('canvas');
canvas.width = CANVAS_WIDTH;
canvas.height = CANVAS_HEIGHT;
const ctx = canvas.getContext('2d');
const clamp01 = x => Math.min(1.0, Math.max(0.0, x));
const toPercentString = p => (p*100).toFixed((p*100 < 10.0) ? 1 : 0);
function toAlpha(p) {
    if (document.getElementById('transparentPathsCheckbox').checked) {
        return interpolateFast(p, 0.2, 1.0);
    }
    return 1.0;
}
function toArrowWidth(p) {
    if (document.getElementById('boldPathsCheckbox').checked) {
        return Math.round(interpolateFast(p, 1, 5));
    }
    return 2;
}
function toArrowHeadLen(p) {
    if (document.getElementById('boldPathsCheckbox').checked) {
        return Math.round(interpolateFast(p, 8, 25));
    }
    return 12;
}
function toNodeBorderWidth(p) {
    if (document.getElementById('boldPathsCheckbox').checked) {
        return Math.round(interpolateFast(p, 1, 5));
    }
    return 2;
}
function toFontWeight(p) {
    if (document.getElementById('boldPathsCheckbox').checked) {
        return Math.round(interpolateFast(p, 100, 900));
    }
    return 400;
}
function interpolateFast(p, min, max) {
    p = clamp01(p);
    p = Math.sqrt(1.0-(1-p)*(1-p)); // fast-in circle function
    return min + (max - min) * p; // linear interpolation between min and max
}
function handleNodeClick(index) {
    probabilityRootNodeIndex = index;
    updateEverything();
}
function updateEverything() {
    updateUrl();
    updateProbabilities();
    updateTables();
    updateNodeStyles();
    drawArrows();
}
function updateUrl() {
    let sliderValues = '';
    for (let i = 0; i < Q; i++) {
        sliderValues += document.getElementById('slider' + i).value;
        if (i + 1 < Q) {
            sliderValues += 'i';
        }
    }
    let params = new URLSearchParams(window.location.search);
    params.set('p', sliderValues);
    window.history.replaceState({}, '', `${window.location.pathname}?${params}`);
}
function updateProbabilities() {
    let sliderProbs = [];
    for (let i = 0; i < Q; i++) {
        sliderProbs.push(parseInt(document.getElementById('slider' + i).value)/100.0);
    }
    nodes[probabilityRootNodeIndex].p = 1.0;
    let np = new Map([[probabilityRootNodeIndex, 1.0]]);
    let ep = new Map();
    function pNode(nIndex) {
        if (np.has(nIndex)) {
            return np.get(nIndex);
        }
        let p = (adj.get(nIndex)||[]).map(eIndex => pEdge(eIndex)).reduce((a, b) => a + b, 0.0);
        np[nIndex] = p;
        nodes[nIndex].p = p;
        return p;
    }
    function pEdge(eIndex) {
        if (ep.has(eIndex)) {
            return ep.get(eIndex);
        }
        let edge = edges[eIndex];
        let pParent = pNode(edge.source);
        let p = 1.0;
        if (edge.yn !== E100) {
            let pSlider = sliderProbs[normalNodesIndices.indexOf(edge.source)];
            mycheck(pSlider, `No slider value for node ${edge.source} from edge ${eIndex}`);
            p = edge.yn === YES ? pSlider : 1.0 - pSlider;
        }
        p *= pParent;
        ep.set(eIndex, p);
        edges[eIndex].p = p;
        return p;
    }
    for (let i = 0; i < N; i++) {
        pNode(i);
    }
    for (let i = 0; i < E; i++) {
        pEdge(i);
    }     
}
function updateTables() {
    for (let i = 0; i < N; i++) {
        let cell = document.getElementById('pNodeCell' + i);
        if (cell) {
            cell.innerText = toPercentString(nodes[i].p);
        }
    }
    for (let i = 0; i < TABLE_NODE_TYPES.length; i++) {
        if (!TABLE_NODE_TYPES_WITH_TOTAL.includes(TABLE_NODE_TYPES[i])) {
            continue;
        }
        let total = nodes.filter(n => n.type === TABLE_NODE_TYPES[i]).map(n => n.p).reduce((a, b) => a + b, 0.0);
        document.getElementById(idPTableTotalForType + TABLE_NODE_TYPES[i]).innerText = toPercentString(total);
    }
}
function updateNodeStyles() {
    for (let i = 0; i < N; i++) {
        let nodeBox = document.getElementById(idDivNodeBox+i);
        let nodeText = document.getElementById(idDivNodeText+i);
        nodeBox.style.width = (parseFloat(window.getComputedStyle(nodeText).width) + 16) + 'px';
        nodeBox.style.height =(parseFloat(window.getComputedStyle(nodeText).height) + 16) + 'px';
        nodeBox.style.opacity = toAlpha(nodes[i].p);
        nodeText.style.fontWeight = toFontWeight(nodes[i].p);
        nodeBox.style.borderWidth = toNodeBorderWidth(nodes[i].p) + 'px';
        if (i == probabilityRootNodeIndex) {
            nodeBox.style.borderColor = 'orange';
        } else {
            nodeBox.style.borderColor = 'black';
        }
    }
}
function drawArrows() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const canvasRect = document.getElementById(`canvas-container`).getBoundingClientRect()
    for (let i = 0; i < E; i++) {
        const edge = edges[i];
        const box1 = document.getElementById(idDivNodeBox+edge.source);
        const box2 = document.getElementById(idDivNodeBox+edge.target);
        const rect1 = box1.getBoundingClientRect();
        const rect2 = box2.getBoundingClientRect();
        let x1 = rect1.left - canvasRect.left + rect1.width / 2;
        let y1 = rect1.top - canvasRect.top + rect1.height / 2;
        let x2 = rect2.left - canvasRect.left + rect2.width / 2;
        let y2 = rect2.top - canvasRect.top + rect2.height / 2;
        let dx = parseFloat(x2) - x1;
        let dy = parseFloat(y2) - y1;
        // Make arrow endpoints align with mid-line or corner points of the boxes.
        if (dx > rect1.width / 2) {
            x1 += rect1.width / 2;
        } else if (dx < -rect1.width / 2) {
            x1 -= rect1.width / 2;
        }
        if (dy > rect1.height / 2) {
            y1 += rect1.height / 2;
        } else if (dy < -rect1.height / 2) {
            y1 -= rect1.height / 2;
        }
        if (dx > (rect1.width + rect2.width) / 2) {
            x2 -= rect2.width / 2;
        } else if (dx < -(rect1.width + rect2.width) / 2) {
            x2 += rect2.width / 2;
        }
        if (dy > (rect1.height + rect2.height) / 2) {
            y2 -= rect2.height / 2;
        } else if (dy < -(rect1.height + rect2.height) / 2) {
            y2 += rect2.height / 2;
        }
        x1 -= 1; // for some reasons these are needed to make the arrows look perfectly aligned.
        x2 -= 1;
        y1 -= 1;
        y2 -= 1;

        updateEdgeLabel(i, x1, y1, x2, y2);

        dx = parseFloat(x2) - x1; // calculate line offset for arrow head
        dy = parseFloat(y2) - y1;
        let dlen = Math.sqrt(dx*dx + dy*dy);
        dx = dx / dlen * toArrowHeadLen(edge.p) * 0.866;
        dy = dy / dlen * toArrowHeadLen(edge.p) * 0.866;
        
        // Draw the line
        ctx.beginPath();
        ctx.moveTo(x1 - canvas.offsetLeft, y1 - canvas.offsetTop);
        // Retract the line end a bit so that it doesn't overlap the arrow head.
        ctx.lineTo(x2 - canvas.offsetLeft - dx, y2 - canvas.offsetTop - dy);
        ctx.strokeStyle = `rgba(0, 0, 0, ${toAlpha(edge.p)}`;
        ctx.lineWidth = toArrowWidth(edge.p);
        ctx.stroke();

        // Draw the arrow head
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const headlen = toArrowHeadLen(edge.p);  // length of head in pixels
        ctx.beginPath();
        ctx.moveTo(x2 - canvas.offsetLeft, y2 - canvas.offsetTop);
        ctx.lineTo(x2 - canvas.offsetLeft - headlen * Math.cos(angle - Math.PI / 6), y2 - canvas.offsetTop - headlen * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(x2 - canvas.offsetLeft - headlen * Math.cos(angle + Math.PI / 6), y2 - canvas.offsetTop - headlen * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(x2 - canvas.offsetLeft, y2 - canvas.offsetTop);
        ctx.closePath();
        ctx.fillStyle = `rgba(0, 0, 0, ${toAlpha(edge.p)}`;
        ctx.fill();
    }
}
function updateEdgeLabel(i, x1, y1, x2, y2) {
    const edgeLabel = document.getElementById(`edge-label${i}`);
    let dx = y2 - y1;
    let dy = x1 - x2;
    const norm = Math.sqrt(dx*dx + dy*dy);
    const offset = 10;
    dx = dx / norm * offset;
    dy = dy / norm * offset;
    edgeLabel.style.left = dx + (x1 + x2) / 2 + 'px';
    edgeLabel.style.top = dy + (y1 + y2) / 2 + 'px';
    edgeLabel.style.opacity = toAlpha(edges[i].p);
    edgeLabel.style.fontWeight = toFontWeight(edges[i].p);
}
function setSlidersFromString(s) {
    let parts = s.split('i');
    for (let i = 0; i < Q; i++) {
        let slider = document.getElementById('slider' + i);
        let textbox = document.getElementById('slidernumberbox' + i);
        slider.value = parseInt(parts[i]) || SLIDER_DEFAULT_VALUE;
        textbox.value = slider.value;
    }
    updateEverything();
}
function copyUrlToClipboard() {
    const url = window.location.href;
    navigator.clipboard.writeText(url).then(function() {
        alert('URL copied to clipboard');
    }, function(err) {
        alert('Failed to copy URL to clipboard');
    });
}
function shareOnFacebook() {
    const fbUrl = `https://www.facebook.com/sharer/sharer.php?u=${getUrl()}`;
    window.open(fbUrl, '_blank');
}
function shareOnTwitter() {
    const twUrl = `https://twitter.com/intent/tweet?&url=${getUrl()}`;
    window.open(twUrl, '_blank');
}
function getUrl() {
    return encodeURIComponent(window.location.href);
    // return encodeURIComponent('https://swantescholz.github.io/aidoom/v1.html');
}
function mycheck(value, message) {
    if (value === null || value === undefined) {
        throw new Error('Value is null or undefined. Error message: ' + message);
    }
}
window.onload = function () {
    let urlParam = new URLSearchParams(window.location.search).get('p') || '';
    setSlidersFromString(urlParam);
    // Slider listeners.
    for (let i = 0; i < Q; i++) {
        let slider = document.getElementById('slider' + i);
        let textbox = document.getElementById('slidernumberbox' + i);
        slider.addEventListener('input', function () {
            textbox.value = slider.value;
            updateEverything();
        });
        textbox.addEventListener('input', function () {
            if (textbox.value < 0) {
                textbox.value = 0;
            } else if (textbox.value > 100) {
                textbox.value = 100;
            }
            slider.value = textbox.value;
            updateEverything();
        });
    }
    updateEverything();
};
window.onresize = updateEverything;

// ================================ END
</script>
</body>
</html>
