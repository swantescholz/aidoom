<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Map of AI Doom</title>
<style>
    body, html {
        height: 100%;
        margin: 10px;
        font-family: Arial, sans-serif;
        font-size: smaller;
    }
    canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none; /* This allows clicking through the canvas */
    }
    table {
        margin: 10px;
        border: 1px solid black;
        border-collapse: collapse;
    }
    td, th {
        border: 1px solid black;
        padding-left: 5px;
        padding-right: 5px;
        height: auto;
    }
    input[type="number"] {
        margin-left: 5px; /* Adds some space around the inputs */
    }
    input[type="number"] {
        width: 40px; /* Fixed width for the number inputs */
    }
    input[type="range"] {
        flex-grow: 1; /* Allows the slider to fill the rest of the container */
    }
    #mainContent {}
    #layoutRow1 {
        display: flex;
        align-items: center; 
    }
    #layoutRow2 {
        display: flex;
        align-items: flex-start; 
    }
    #canvas-container {
        position: relative;
        border: 1px solid black;
        flex-shrink: 0;
        margin: 5px;
    }
    #slider-container-outer {
        max-width: 300px;
        padding: 10px;
        border: 1px solid black;
        flex-shrink: 0;
    }
    #shareRow {
        display: flex;
        align-items: center; 
        margin: 10px;
    }
    .node {
        position: absolute;
        border: 1px solid black;
        text-align: center;
        padding: 5px;
        max-width: 100px;
        transform: translate(-50%, -50%);
    }
    .edge-label {
        position: absolute;
        text-align: center;
        transform: translate(-50%, -50%);
    }
    .tablePercent {
        text-align: right;
        width: 30px;
    }
    .bgs { background-color: rgb(114, 158, 240);}
    .bgn { background-color: rgb(255, 255, 255); }
    .bgi { background-color: rgb(168, 191, 171); }
    .bgg { background-color: rgb(97, 247, 115); }
    .bga { background-color: rgb(244, 244, 99); }
    .bgc { background-color: rgb(234, 138, 49); }
    .bge { background-color: rgb(223, 94, 55); }
    .slider-container-inner {
        width: 100%;
        display: flex;         /* Aligns children (slider and textbox) in a row */
        align-items: center;     /* Centers the children vertically */
    }
    .shareButton {
        margin: 10px;
    }
</style>
</head>
<body>
<script>

// NORMAL nodes first! then the rest!
let nodesStr = `
s;sstart;8;4;START|HERE
n;nnon-ai-catastrophe;8;6;Non-AI catastrophe occurs soon (e.g. nuclear war)?
n;nnon-ai-recover;6;8;Humanity recovers from non-AI catastrophe?
e;enon-ai-xrisk;6;6;Extinction from non-AI catastrophe
n;ntry-stop1;10;6;Humanity permanently fully stops frontier AI development soon?
a;adune;12;6;"Dune"-scenario: Advanced AI is permanently banned.
i;iresearch-continues;8;8;AI research continues
n;ncapabilities-improve;8;10;Will frontier AI capabilities continue to improve?
a;aai-winter;6;10;Permanent AI winter
i;ireach-catastrophic-potential;10;8;Frontier AI reaches capabilities with catastrophic potential.
n;ncatastrophe;10;10;pre-AGI catastrophe occurs (e.g. AI misuse via cyber- or bio-weapons)?
c;ccatastrophy-occurs;11.2;8;pre-AGI catastrophe does occur!
n;ntry-stop2;12;10;Humanity permanently fully stops frontier AI development (after catastrophe)?
n;ntry-slow;12;12;Humanity agrees to advance AI only extremely carefully to avoid risks?
n;nenforce-slow;12;14;Can Humanity enforce this slow/careful approach globally?
g;gagi-utopia;12;16;(Slightly delayed) AGI utopia
i;iagi-exists;10;14;Research towards AGI continues. First AGI exists
n;nagi-transformative;8;14;Is AGI transformative?
a;anon-transformative-agi;8;12;Powerful, but not transformative AGI.
n;nprevent-other-agis;6;12;Will the first AGI prevent other AGIs to appear?
n;nagis-collaborate;4;12;Will AGIs collaborate with each other?
i;iconflicting-agis;4;10;Conflicting AGIs
n;nconflicting-agi-survive;4;6;Will humanity survive among conflicting AGIs?
e;econflicting-agi-xrisk;4;4;Extinction from conflicting AGIs
a;aconflicting-agi-survive;6;4;Uncertain future among conflicting AGIs
n;nalignment-theory;6;14;Have we solved AGI alignment in theory?
n;nimplement-alignment;6;16;Do AI labs implement alignment correctly?
i;ialigned-agi;4;16;Aligned AGI
n;nwhole-humanity-aligned;4;18;Is AGI aligned with humanity's interests as a whole?
g;gagi-utopia2;4;20;AGI utopia
n;ncontrollers-thoughtful;6;18;Are AGI controllers thoughtful regarding unintended consequences?
n;nagi-protects;8;20;Does AGI protect its users?
e;estupid-xrisk;8;22;Accidental/stupid human extinction
n;ncontrollers-good;6;20;Do AGI controllers have good intentions?
e;eauthoritarian-dystopia;6;22;Authoritarian dystopia
i;imisaligned-agi;8;16;Misaligned AGI
n;nfigure-misaligned;8;18;Do we figure out it's misaligned?
n;nturn-off;10;18;Can we easily turn it off?
a;asecond-chance;12;18;We get a second chance at building AGI
n;nharming-us;10;20;Is it harming us?
n;ncan-destroy-it;12;20;Can we destroy it?
n;nbenefit-extinction;12;22;Does it benefit from our extinction?
e;eagi-kills-us;12;24;AGI-initiated human extinction
n;nbenefit-suffering;10;24;Does it benefit from our suffering?
e;emedium-dystopia;10;22;Medium-scale dystopia
e;esuffering;8;24;Astronomical suffering
`.trim();

let edgesStr = `
-;sstart;nnon-ai-catastrophe
y;nnon-ai-catastrophe;nnon-ai-recover
n;nnon-ai-catastrophe;ntry-stop1
y;ntry-stop1;adune
n;ntry-stop1;iresearch-continues
y;nnon-ai-recover;iresearch-continues
n;nnon-ai-recover;enon-ai-xrisk
-;iresearch-continues;ncapabilities-improve
y;ncapabilities-improve;ireach-catastrophic-potential
n;ncapabilities-improve;aai-winter
-;ireach-catastrophic-potential;ncatastrophe
y;ncatastrophe;ccatastrophy-occurs
-;ccatastrophy-occurs;ntry-stop2
y;ntry-stop2;adune
n;ntry-stop2;ntry-slow
y;ntry-slow;nenforce-slow
n;ntry-slow;iagi-exists
y;nenforce-slow;gagi-utopia
n;nenforce-slow;iagi-exists
n;ncatastrophe;iagi-exists
-;iagi-exists;nagi-transformative
n;nagi-transformative;anon-transformative-agi
y;nagi-transformative;nprevent-other-agis
n;nprevent-other-agis;nagis-collaborate
y;nprevent-other-agis;nalignment-theory
y;nagis-collaborate;iconflicting-agis
n;nagis-collaborate;nalignment-theory
-;iconflicting-agis;nconflicting-agi-survive
n;nconflicting-agi-survive;econflicting-agi-xrisk
y;nconflicting-agi-survive;aconflicting-agi-survive
y;nalignment-theory;nimplement-alignment
n;nalignment-theory;imisaligned-agi
n;nimplement-alignment;imisaligned-agi
y;nimplement-alignment;ialigned-agi
-;ialigned-agi;nwhole-humanity-aligned
n;nwhole-humanity-aligned;ncontrollers-thoughtful
y;nwhole-humanity-aligned;gagi-utopia2
n;ncontrollers-thoughtful;nagi-protects
y;ncontrollers-thoughtful;ncontrollers-good
y;nagi-protects;ncontrollers-good
n;nagi-protects;estupid-xrisk
n;ncontrollers-good;eauthoritarian-dystopia
y;ncontrollers-good;gagi-utopia2
-;imisaligned-agi;nfigure-misaligned
y;nfigure-misaligned;nturn-off
n;nfigure-misaligned;nharming-us
y;nturn-off;asecond-chance
n;nturn-off;nharming-us
y;nharming-us;ncan-destroy-it
n;nharming-us;asecond-chance
y;ncan-destroy-it;asecond-chance
n;ncan-destroy-it;nbenefit-extinction
y;nbenefit-extinction;eagi-kills-us
n;nbenefit-extinction;nbenefit-suffering
y;nbenefit-suffering;esuffering
n;nbenefit-suffering;emedium-dystopia
`.trim();

// Edge types
const YES = 'y';
const NO = 'n';
const E100 = '-';

// Node types:
const NORMAL = 'n';
const START = 's';
const GOOD = 'g';
const AMBIVALENT = 'a';
const CATASTROPHIC = 'c';
const EXISTENTIAL = 'e';
const INTERMEDIATE = 'i';

// Other constants
const XSCALE = 1.0;
const SLIDER_DEFAULT_VALUE = 50;
const TABLE_NODE_TYPES_WITH_TOTAL = [EXISTENTIAL, AMBIVALENT, GOOD];
const TABLE_NODE_TYPES = [EXISTENTIAL, AMBIVALENT, GOOD, CATASTROPHIC, INTERMEDIATE, NORMAL];
const TABLE_HEADERS = ["Existential Catastrophe", "Ambivalent Outcome", "Good Outcome", "Non-existential Catastrophe", "Intermediate State", "Question Nodes (propability<br>of *entering* this node)"];

let gNodeIndex = 0;

class Node {
    constructor(line) {
        const parts = line.trim().split(';');
        this.index = gNodeIndex++;
        this.id = parts[1];
        this.type = parts[0];
        this.x = parseFloat(parts[2]) * XSCALE;
        this.y = parseFloat(parts[3]);
        this.text = parts[4].replace('|', '\n');
        this.p = 1.0; // total probability flow going into this node.
    }
}
const CANVAS_PADDINGW = 100;
const CANVAS_PADDINGH = 50;
const CANVAS_WIDTH = 1200;
const CANVAS_HEIGHT = 1200;
function initNodes() {
    let nodes = nodesStr.split('\n').map(line => new Node(line));
    let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
    nodes.map(node => {
        minX = Math.min(minX, node.x);
        minY = Math.min(minY, node.y);
        maxX = Math.max(maxX, node.x);
        maxY = Math.max(maxY, node.y);
    });
    nodes.map(node => {
        node.x = (node.x - minX) / (maxX-minX) * (CANVAS_WIDTH - 2*CANVAS_PADDINGW) + CANVAS_PADDINGW;
        node.y = (node.y - minY) / (maxY-minY) * (CANVAS_HEIGHT - 2*CANVAS_PADDINGH) + CANVAS_PADDINGH;
    })
    return nodes;
}
const nodes = initNodes();
let id2index = new Map();
nodes.map((node, index) => {
    id2index.set(node.id, index);
});
const normalNodesIndices = nodes.filter(n => n.type === NORMAL).map(n => n.index);

class Edge {
    constructor(line) {
        const parts = line.trim().split(';');
        this.yn = parts[0];
        this.source = id2index.get(parts[1]);
        this.target = id2index.get(parts[2]);
        mycheck(this.source, `Unknown node: ${parts[1]}`);
        mycheck(this.target, `Unknown node: ${parts[2]}`);
        this.p = 0.0; // total probability flow going through the edge.
    }
}

let edges = edgesStr.split('\n').map(line => new Edge(line));
const Q = normalNodesIndices.length;
const N = nodes.length;
const E = edges.length;

let adj = new Map();
edges.map((edge, eIndex) => {
    if (!adj.has(edge.target)) {
        adj.set(edge.target, []);
    }
    adj.get(edge.target).push(eIndex);
});
// ================================ HEADER 
document.write(`
<div id="mainContent">
    <h1>Map of AI Doom (<a href="http://bit.ly/map-of-ai-doom">bit.ly/map-of-ai-doom</a>)</h1>
    
    TODO:
    <br>Legend/glossary. 
    <br>Explain sliders use conditional probabilities.
    <br>Define catastrophic risks.
    <br>add authors, and link to source code. mention unlicense, so people know they may modify etc.
`);

// ================================ SHARING / EXPORT
document.write(`
<div id="shareRow">
<h2>Share this page:</h2>
    <button onclick="copyUrlToClipboard()" class="shareButton">Copy URL to Clipboard</button>
    <button onclick="shareOnFacebook()" class="shareButton">Share on Facebook</button>
    <button onclick="shareOnTwitter()" class="shareButton">Share on X (Twitter)</button>
</div>
`);
// ================================ ROW 1

document.write(`<div id="layoutRow1">`);
document.write(`<div id="canvas-container" style="width: ${CANVAS_WIDTH}px; height: ${CANVAS_HEIGHT}px">`);
    document.write(`<canvas s></canvas>`);
nodes.map(node => {
    document.write(`
<div id="node${node.index}" class="node bg${node.type}" style="top: ${node.y}px; left: ${node.x}px;">
    ${node.text.replace(/\n/g, '<br>')}
</div>`);
});
edges.map((edge, index) => {
    document.write(`<div id="edge-label${index}" class="edge-label">${edge.yn === E100 ? "" : edge.yn}</div>`);
});
document.write(`</div>`); // /canvas-container
document.write(`<div id=slider-container-outer>`); // slider
    // Settings
    document.write(`
<div class="slider-container-inner"> 
    <p style="padding-left: 5px">Make more likely paths bolder?</p>
    <input type="checkbox" id="boldPathsCheckbox" onclick="updateEverything()" checked>
</div>
<div class="slider-container-inner"> 
    <p style="padding-left: 5px">Make less likely paths transparent?</p>
    <input type="checkbox" id="transparentPathsCheckbox" onclick="updateEverything()" checked>
</div>
<hr>
<button onclick="setSlidersFromString('')">Reset all to 50%</button>
<button onclick="setSlidersFromString('4i80i1i90i55i10i30i10i97i60i70i3i75i70i50i80i90i75i25i5i80i6i92i2')">Author's estimates</button>
<hr>
`);

for (let i = 0; i < Q; i++) {
    document.write(`
<p style="padding-left: 5px">${nodes[normalNodesIndices[i]].text.trim()}</p>
<div class="slider-container-inner"> 
    <input type="range" id="slider${i}" min="0" max="100" value="${SLIDER_DEFAULT_VALUE}"> 
    <input type="number" id="slidernumberbox${i}" min="0" max="100" value="${SLIDER_DEFAULT_VALUE}"> 
</div>
`);
}
document.write('</div>'); // /slider
document.write(`</div>`); // /layoutRow1
// ================================ ROW 2
document.write(`<div id="layoutRow2">`);
for (let i = 0; i < TABLE_NODE_TYPES.length; i++) {
    document.write(`<table class="bg${TABLE_NODE_TYPES[i]}"><tr><th>${TABLE_HEADERS[i]}</th><th class="ralign">[%]</th></tr>`);
        if (TABLE_NODE_TYPES_WITH_TOTAL.includes(TABLE_NODE_TYPES[i])) {
            document.write(`<tr><td><b>Total</b></td><td class="tablePercent"><b><p id="pTableTotalForType${TABLE_NODE_TYPES[i]}">0.0</p></b></td></tr>`);
        } 
    nodes.filter(n => n.type === TABLE_NODE_TYPES[i]).map(node => {
        document.write(`<tr><td>${node.text}</td><td class="tablePercent"><p id="pNodeCell${node.index}">0.0</p></td></tr>`);
    });
    document.write(`</table>`);
}
document.write(`</div>`); // /layoutRow2
document.write(`</div>`); // /mainContent
// ================================ FUNCTIONS / LOGIC
const canvas = document.querySelector('canvas');
canvas.width = CANVAS_WIDTH;
canvas.height = CANVAS_HEIGHT;
const ctx = canvas.getContext('2d');
const clamp01 = x => Math.min(1.0, Math.max(0.0, x));
const toPercentString = p => (p*100).toFixed(1);
function toAlpha(p) {
    if (document.getElementById('transparentPathsCheckbox').checked) {
        return interpolateFast(p, 0.2, 1.0);
    }
    return 1.0;
}
function toArrowWidth(p) {
    if (document.getElementById('boldPathsCheckbox').checked) {
        return interpolateFast(p, 1, 5);
    }
    return 2;
}
function toArrowHeadLen(p) {
    if (document.getElementById('boldPathsCheckbox').checked) {
        return interpolateFast(p, 8, 25);
    }
    return 12;
}
function toNodeBorderWidth(p) {
    if (document.getElementById('boldPathsCheckbox').checked) {
        return interpolateFast(p, 1, 5);
    }
    return 2;
}
function toNodeFontWeight(p) {
    if (document.getElementById('boldPathsCheckbox').checked) {
        return interpolateFast(p, 100, 900);
    }
    return 400;
}
function interpolateFast(p, min, max) {
    p = clamp01(p);
    p = Math.sqrt(1.0-(1-p)*(1-p)); // fast-in circle function
    return min + (max - min) * p; // linear interpolation between min and max
}
function updateEverything() {
    updateUrl();
    updateProbabilities();
    updateTables();
    updateNodeStyles();
    drawArrows();
}
function updateUrl() {
    let sliderValues = '';
    for (let i = 0; i < Q; i++) {
        sliderValues += document.getElementById('slider' + i).value;
        if (i + 1 < Q) {
            sliderValues += 'i';
        }
    }
    let params = new URLSearchParams(window.location.search);
    params.set('p', sliderValues);
    window.history.replaceState({}, '', `${window.location.pathname}?${params}`);
}
function updateProbabilities() {
    let sliderProbs = [];
    for (let i = 0; i < Q; i++) {
        sliderProbs.push(parseInt(document.getElementById('slider' + i).value)/100.0);
    }
    const startNodeIndex = nodes.findIndex(n => n.type === START);
    let np = new Map([[startNodeIndex, 1.0]]);
    let ep = new Map();
    function pNode(nIndex) {
        if (np.has(nIndex)) {
            return np.get(nIndex);
        }
        let p = (adj.get(nIndex)||[]).map(eIndex => pEdge(eIndex)).reduce((a, b) => a + b, 0.0);
        np[nIndex] = p;
        nodes[nIndex].p = p;
        return p;
    }
    function pEdge(eIndex) {
        if (ep.has(eIndex)) {
            return ep.get(eIndex);
        }
        let edge = edges[eIndex];
        let pParent = pNode(edge.source);
        let p = 1.0;
        if (edge.yn !== E100) {
            let pSlider = sliderProbs[normalNodesIndices.indexOf(edge.source)];
            mycheck(pSlider, `No slider value for node ${edge.source} from edge ${eIndex}`);
            p = edge.yn === YES ? pSlider : 1.0 - pSlider;
        }
        console.log('pEdge', eIndex, p, pParent);
        p *= pParent;
        ep.set(eIndex, p);
        edges[eIndex].p = p;
        return p;
    }
    for (let i = 0; i < N; i++) {
        pNode(i);
    }    
}
function updateTables() {
    for (let i = 0; i < N; i++) {
        let cell = document.getElementById('pNodeCell' + i);
        if (cell) {
            cell.innerText = toPercentString(nodes[i].p);
        }
    }
    for (let i = 0; i < TABLE_NODE_TYPES.length; i++) {
        if (!TABLE_NODE_TYPES_WITH_TOTAL.includes(TABLE_NODE_TYPES[i])) {
            continue;
        }
        let total = nodes.filter(n => n.type === TABLE_NODE_TYPES[i]).map(n => n.p).reduce((a, b) => a + b, 0.0);
        document.getElementById('pTableTotalForType' + TABLE_NODE_TYPES[i]).innerText = toPercentString(total);
    }
}
function updateNodeStyles() {
    for (let i = 0; i < N; i++) {
        let nodeDiv = document.getElementById(`node${i}`);
        nodeDiv.style.opacity = toAlpha(nodes[i].p);
        nodeDiv.style.fontWeight = toNodeFontWeight(nodes[i].p);
        nodeDiv.style.borderWidth = toNodeBorderWidth(nodes[i].p) + 'px';
    }
}
function drawArrows() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const canvasRect = document.getElementById(`canvas-container`).getBoundingClientRect()
    for (let i = 0; i < E; i++) {
        const edge = edges[i];
        const box1 = document.getElementById(`node${edge.source}`);
        const box2 = document.getElementById(`node${edge.target}`);
        const rect1 = box1.getBoundingClientRect();
        const rect2 = box2.getBoundingClientRect();
        let x1 = rect1.left - canvasRect.left + rect1.width / 2;
        let y1 = rect1.top - canvasRect.top + rect1.height / 2;
        let x2 = rect2.left - canvasRect.left + rect2.width / 2;
        let y2 = rect2.top - canvasRect.top + rect2.height / 2;
        let dx = parseFloat(x2) - x1;
        let dy = parseFloat(y2) - y1;
        // Make arrow endpoints align with mid-line or corner points of the boxes.
        if (dx > rect1.width / 2) {
            x1 += rect1.width / 2;
        } else if (dx < -rect1.width / 2) {
            x1 -= rect1.width / 2;
        }
        if (dy > rect1.height / 2) {
            y1 += rect1.height / 2;
        } else if (dy < -rect1.height / 2) {
            y1 -= rect1.height / 2;
        }
        if (dx > (rect1.width + rect2.width) / 2) {
            x2 -= rect2.width / 2;
        } else if (dx < -(rect1.width + rect2.width) / 2) {
            x2 += rect2.width / 2;
        }
        if (dy > (rect1.height + rect2.height) / 2) {
            y2 -= rect2.height / 2;
        } else if (dy < -(rect1.height + rect2.height) / 2) {
            y2 += rect2.height / 2;
        }
        x1 -= 1; // for some reasons these are needed to make the arrows look perfectly aligned.
        x2 -= 1;
        y1 -= 1;
        y2 -= 1;

        updateEdgeLabel(i, x1, y1, x2, y2);

        dx = parseFloat(x2) - x1; // calculate line offset for arrow head
        dy = parseFloat(y2) - y1;
        let dlen = Math.sqrt(dx*dx + dy*dy);
        dx = dx / dlen * toArrowHeadLen(edge.p) * 0.866;
        dy = dy / dlen * toArrowHeadLen(edge.p) * 0.866;
        
        // Draw the line
        ctx.beginPath();
        ctx.moveTo(x1 - canvas.offsetLeft, y1 - canvas.offsetTop);
        // Retract the line end a bit so that it doesn't overlap the arrow head.
        ctx.lineTo(x2 - canvas.offsetLeft - dx, y2 - canvas.offsetTop - dy);
        ctx.strokeStyle = `rgba(0, 0, 0, ${toAlpha(edge.p)}`;
        ctx.lineWidth = toArrowWidth(edge.p);
        ctx.stroke();

        // Draw the arrow head
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const headlen = toArrowHeadLen(edge.p);  // length of head in pixels
        ctx.beginPath();
        ctx.moveTo(x2 - canvas.offsetLeft, y2 - canvas.offsetTop);
        ctx.lineTo(x2 - canvas.offsetLeft - headlen * Math.cos(angle - Math.PI / 6), y2 - canvas.offsetTop - headlen * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(x2 - canvas.offsetLeft - headlen * Math.cos(angle + Math.PI / 6), y2 - canvas.offsetTop - headlen * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(x2 - canvas.offsetLeft, y2 - canvas.offsetTop);
        ctx.closePath();
        ctx.fillStyle = `rgba(0, 0, 0, ${toAlpha(edge.p)}`;
        ctx.fill();
    }
}
function updateEdgeLabel(i, x1, y1, x2, y2) {
    const edgeLabel = document.getElementById(`edge-label${i}`);
    let dx = y2 - y1;
    let dy = x1 - x2;
    const norm = Math.sqrt(dx*dx + dy*dy);
    const offset = 8 + toArrowWidth(edges[i].p) * 0.5
    dx = dx / norm * offset;
    dy = dy / norm * offset;
    edgeLabel.style.left = dx + (x1 + x2) / 2 + 'px';
    edgeLabel.style.top = dy + (y1 + y2) / 2 + 'px';
    edgeLabel.style.opacity = toAlpha(edges[i].p);
}
function setSlidersFromString(s) {
    let parts = s.split('i');
    for (let i = 0; i < Q; i++) {
        let slider = document.getElementById('slider' + i);
        let textbox = document.getElementById('slidernumberbox' + i);
        slider.value = parseInt(parts[i]) || SLIDER_DEFAULT_VALUE;
        textbox.value = slider.value;
    }
    updateEverything();
}
function copyUrlToClipboard() {
    const url = window.location.href;
    navigator.clipboard.writeText(url).then(function() {
        alert('URL copied to clipboard');
    }, function(err) {
        alert('Failed to copy URL to clipboard');
    });
}
function shareOnFacebook() {
    const fbUrl = `https://www.facebook.com/sharer/sharer.php?u=${getUrl()}`;
    window.open(fbUrl, '_blank');
}
function shareOnTwitter() {
    const twUrl = `https://twitter.com/intent/tweet?text=Check out this cool interactive graph about catastrophic AI risks!&url=${getUrl()}`;
    window.open(twUrl, '_blank');
}
function getUrl() {
    return encodeURIComponent(window.location.href);
    // return encodeURIComponent('https://swantescholz.github.io/aidoom/v1.html');
}
function mycheck(value, message) {
    if (value === null || value === undefined) {
        throw new Error('Value is null or undefined. Error message: ' + message);
    }
}
window.onload = function () {
    let urlParam = new URLSearchParams(window.location.search).get('p') || '';
    setSlidersFromString(urlParam);
    // Slider listeners.
    for (let i = 0; i < Q; i++) {
        let slider = document.getElementById('slider' + i);
        let textbox = document.getElementById('slidernumberbox' + i);
        slider.addEventListener('input', function () {
            textbox.value = slider.value;
            updateEverything();
        });
        textbox.addEventListener('input', function () {
            if (textbox.value < 0) {
                textbox.value = 0;
            } else if (textbox.value > 100) {
                textbox.value = 100;
            }
            slider.value = textbox.value;
            updateEverything();
        });
    }
    updateEverything();
};
window.onresize = updateEverything;

// ================================ END
</script>
</body>
</html>
